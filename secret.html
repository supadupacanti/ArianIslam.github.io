<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Canti's Secret Games</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=Open+Sans:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg-dark: #1b1a1a;
      --bg-darker: #0d0c0b;
      --text-primary: #4b96eb;
      --text-secondary: #beceed;
      --border-color: #edfaf1;
      --accent-color: #f25df5;
      --shadow-glow: rgba(75,150,235,0.6);
    }
    body {
      font-family: 'Open Sans', Arial, sans-serif;
      margin: 0;
      background-color: var(--bg-darker);
      color: #c0c0c0;
      line-height: 1.6;
      user-select: none;
    }
    header {
      background-image: url("https://i.pinimg.com/originals/52/18/9c/52189c28e68e7712f74b7c1eb26b1f86.gif");
      background-size: cover;
      background-position: center;
      color: var(--text-secondary);
      padding: 3em 1em 2em;
      text-align: center;
      border-bottom-left-radius: 48px;
      border-bottom-right-radius: 48px;
      position: relative;
      overflow: hidden;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.7);
    }
    header::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(130deg, rgba(27,26,26,0.7), transparent 75%);
      pointer-events: none;
      border-bottom-left-radius: 48px;
      border-bottom-right-radius: 48px;
    }
    header h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 3rem;
      margin: 0 0 0.2em;
      position: relative;
      z-index: 1;
      letter-spacing: 3px;
      color: var(--text-secondary);
    }
    header .subtitle {
      font-size: 1.3em;
      z-index: 1;
      font-style: italic;
      position: relative;
      color: var(--text-secondary);
    }
    nav {
      background-color: var(--bg-dark);
      display: flex;
      justify-content: center;
      gap: 24px;
      padding: 1rem 1rem;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 3px 8px rgba(0,0,0,0.7);
      border-bottom-left-radius: 18px;
      border-bottom-right-radius: 18px;
    }
    nav a {
      color: white;
      text-decoration: none;
      font-weight: 700;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.1rem;
      padding: 12px 20px;
      border-radius: 12px;
      transition: background-color 0.25s, color 0.25s;
      user-select: none;
      cursor: pointer;
    }
    nav a.active,
    nav a.secret-link {
      background: linear-gradient(45deg, var(--text-primary), var(--accent-color));
      color: #222;
      box-shadow: 0 0 12px var(--accent-color);
    }
    nav a:hover,
    nav a:focus {
      background-color: var(--accent-color);
      color: #fff;
      outline: none;
      box-shadow: 0 0 10px var(--accent-color);
    }
    main {
      background-color: var(--bg-dark);
      max-width: 950px;
      margin: 2em auto 5em auto;
      padding: 2em 2.5em;
      border-radius: 20px;
      box-shadow: 0 0 24px var(--shadow-glow);
      text-align: center;
    }
    .tab-buttons {
      display: flex;
      justify-content: center;
      margin-bottom: 2em;
      gap: 1em;
      user-select: none;
      flex-wrap: wrap;
    }
    .tab-button {
      font-family: 'Orbitron', sans-serif;
      padding: 10px 26px;
      border-radius: 24px;
      background: linear-gradient(90deg, var(--text-primary), var(--accent-color));
      color: #222;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.3s, color 0.3s;
      flex-shrink: 0;
      border: none;
    }
    .tab-button.active {
      background: linear-gradient(90deg, var(--accent-color), var(--text-primary));
      color: #fff;
      box-shadow: 0 5px 14px var(--accent-color);
    }
    .tab-button:hover {
      filter: brightness(1.1);
    }
    section.game {display: none; overflow: hidden; position: relative;}
    section.game.active {display: block;}
    .back-link {
      display: inline-block;
      padding: 13px 38px;
      background: linear-gradient(90deg, var(--text-primary), var(--accent-color));
      color: #222;
      font-weight: 700;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.1rem;
      border-radius: 22px;
      text-decoration: none;
      box-shadow: 0 6px 24px #4b96eb96;
      transition: background 0.4s, color 0.3s, transform 0.3s;
      text-align: center;
      user-select: none;
      margin: 2em auto 0;
      display: block;
      width: fit-content;
    }
    .back-link:hover, .back-link:focus {
      background: linear-gradient(90deg, var(--accent-color), var(--text-primary));
      color: #fff;
      outline: none;
      transform: scale(1.07);
      box-shadow: 0 10px 36px #f25df5aa;
    }
    /* Shared game controls */
    .restart-btn {
      margin-top: 1em;
      margin-bottom: 3em;
      background: linear-gradient(90deg, var(--accent-color), var(--text-primary));
      border: none;
      font-size: 1.2rem;
      padding: 14px 32px;
      border-radius: 28px;
      font-weight: 700;
      font-family: 'Orbitron', sans-serif;
      cursor: pointer;
      color: #222;
      box-shadow: 0 8px 24px var(--accent-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .restart-btn:hover {
      background: linear-gradient(90deg, var(--text-primary), var(--accent-color));
      color: #fff;
    }
    /* SNAKE */
    #snake-canvas {
      background-color: #151515;
      border-radius: 20px;
      border: 3px solid var(--accent-color);
      box-shadow: 0 0 20px var(--accent-color);
      display: block;
      margin: 1.8em auto 0 auto;
      width: 100%;
      max-width: 420px;
      height: 420px;
    }
    #snake-score {
      color: var(--text-primary);
      font-family: 'Orbitron', sans-serif;
      font-size: 1.6rem;
      font-weight: 700;
      margin-top: 1em;
    }
    /* MEMORY MATCH */
    #memory-board {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 16px;
      max-width: 480px;
      margin: 0 auto 3em auto;
      user-select: none;
    }
    .memory-card {
      background: var(--bg-darker);
      border: 3px solid var(--accent-color);
      border-radius: 16px;
      box-shadow: 0 0 20px var(--border-color);
      cursor: pointer;
      position: relative;
      height: 110px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3.5rem;
      color: var(--accent-color);
      transition: transform 0.4s;
      transform-style: preserve-3d;
      perspective: 700px;
      user-select:none;
    }
    .memory-card.flip { transform: rotateY(180deg);}
    .memory-card .front, .memory-card .back{
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 16px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .memory-card .front {
      background: var(--bg-darker);
      color: var(--accent-color);
      font-size: 2rem;
    }
    .memory-card .back {
      background: var(--accent-color);
      color: var(--bg-darker);
      transform: rotateY(180deg);
      font-size: 3.5rem;
    }
    /* TIC TAC TOE */
    .tic-tac-toe {
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(3, 1fr);
      max-width: 280px;
      margin: 2em auto 3em;
    }
    .cell {
      background: var(--bg-darker);
      border: 4px solid var(--accent-color);
      padding: 28px 0;
      font-size: 3.8rem;
      font-weight: 700;
      color: var(--accent-color);
      cursor: pointer;
      border-radius: 20px;
      transition: 0.3s background-color 0.25s, color 0.3s;
      text-align:center;
      user-select: none;
    }
    .cell:hover:not(.disabled) {
      background: var(--accent-color);
      color: var(--bg-darker);
    }
    .cell.disabled {
      cursor: default;
      color: #777;
    }
    #message {
      font-size: 1.4rem;
      color: var(--text-secondary);
      min-height: 44px;
      text-align: center;
      margin-bottom: 1.3em;
    }
  </style>
</head>
<body>
  <header>
    <h1>Welcome to Canti's Domain</h1>
    <p class="subtitle">Shhh... This is Secret!</p>
  </header>
  <nav>
    <a href="index.html" aria-label="Home">Home</a>
    <a href="#about" aria-label="About">About</a>
    <a href="#anime" aria-label="Anime">Anime</a>
    <a href="#games" aria-label="Games">Games</a>
    <a href="#hobbies" aria-label="Hobbies">Hobbies</a>
    <a href="#contact" aria-label="Contact">Contact</a>
    <a href="secret.html" class="active secret-link" aria-label="Secret Page">Secret</a>
  </nav>
  <main>
    <div class="tab-buttons" role="tablist" aria-label="Mini Games toggle">
      <button class="tab-button active" id="tab-snake" aria-selected="true" aria-controls="game-snake" role="tab">Snake</button>
      <button class="tab-button" id="tab-memory" aria-selected="false" aria-controls="game-memory" role="tab">Memory Match</button>
      <button class="tab-button" id="tab-tic" aria-selected="false" aria-controls="game-tic" role="tab">Tic Tac Toe</button>
      <button class="tab-button" id="tab-simon" aria-selected="false" aria-controls="game-simon" role="tab">Simon Says</button>
      <button class="tab-button" id="tab-pong" aria-selected="false" aria-controls="game-pong" role="tab">Pong</button>
    </div>

    <section id="game-snake" class="game active" role="tabpanel" aria-labelledby="tab-snake">
      <div id="snake-score" class="scoreboard">Score: 0</div>
      <canvas id="snake-canvas" width="400" height="400" aria-label="Snake game canvas" tabindex="0"></canvas>
      <button class="restart-btn" id="restartSnake">Restart Snake</button>
    </section>

    <section id="game-memory" class="game" role="tabpanel" aria-labelledby="tab-memory">
      <div id="memory-board" aria-live="polite" aria-atomic="true"></div>
      <button class="restart-btn" id="restartMemory">Restart Memory Match</button>
    </section>

    <section id="game-tic" class="game" role="tabpanel" aria-labelledby="tab-tic">
      <div class="tic-tac-toe" id="board" tabindex="0" aria-label="tic tac toe board">
        <div class="cell" data-index="0" role="button" tabindex="0"></div>
        <div class="cell" data-index="1" role="button" tabindex="0"></div>
        <div class="cell" data-index="2" role="button" tabindex="0"></div>
        <div class="cell" data-index="3" role="button" tabindex="0"></div>
        <div class="cell" data-index="4" role="button" tabindex="0"></div>
        <div class="cell" data-index="5" role="button" tabindex="0"></div>
        <div class="cell" data-index="6" role="button" tabindex="0"></div>
        <div class="cell" data-index="7" role="button" tabindex="0"></div>
        <div class="cell" data-index="8" role="button" tabindex="0"></div>
      </div>
      <div id="message" aria-live="polite" aria-atomic="true"></div>
      <button class="restart-btn" id="restartBtn">Restart Tic Tac Toe</button>
    </section>

    <section id="game-simon" class="game" role="tabpanel" aria-labelledby="tab-simon">
      <div id="simon-container" style="max-width: 400px; margin: 0 auto;">
        <div style="display:flex; justify-content:center; gap: 12px; flex-wrap: wrap; margin-top:1em;">
          <button id="btn-green" style="width: 160px; height: 160px; background: #0f0; border-radius: 16px; border:none; box-shadow: 0 0 15px #0f0;" aria-label="Green Button"></button>
          <button id="btn-red" style="width:160px; height:160px; background:#f00; border-radius: 16px; border:none; box-shadow: 0 0 15px #f00;" aria-label="Red Button"></button>
          <button id="btn-yellow" style="width:160px; height:160px; background:#ff0; border-radius: 16px; border:none; box-shadow: 0 0 15px #ff0;" aria-label="Yellow Button"></button>
          <button id="btn-blue" style="width:160px; height:160px; background:#00f; border-radius: 16px; border:none; box-shadow: 0 0 15px #00f;" aria-label="Blue Button"></button>
        </div>
        <p id="simon-message" style="color: var(--text-primary); font-family: 'Orbitron', sans-serif; font-size: 1.4rem; margin-top: 1em;">Press Start to play</p>
        <button class="restart-btn" id="startSimonBtn">Start Simon Says</button>
      </div>
    </section>

    <section id="game-pong" class="game" role="tabpanel" aria-labelledby="tab-pong">
      <canvas id="pong-canvas" width="600" height="400" style="background:#151515; border-radius: 20px; margin: 1.5em auto; border: 4px solid var(--accent-color); box-shadow: 0 0 20px var(--accent-color);" aria-label="Pong game canvas"></canvas>
      <div id="pong-score" style="color: var(--text-primary); font-family: 'Orbitron', sans-serif; font-size: 1.6rem; margin-top: 1em;">Player 1: 0 | Player 2: 0</div>
      <button class="restart-btn" id="restartPong">Restart Pong</button>
      <p style="color: var(--text-muted); font-family: 'Open Sans'; font-size: 0.9rem; margin-top: 0.5em;">Player 1: W (up), S (down) | Player 2: Up &amp; Down Arrows</p>
    </section>

    <a href="index.html" class="back-link" aria-label="Back to main website">‚Üê Back to Website</a>
  </main>
<script>
  const tabs = document.querySelectorAll('.tab-button');
  const panels = document.querySelectorAll('section.game');
  tabs.forEach(tab => tab.addEventListener('click', () => {
    const target = tab.getAttribute('aria-controls');
    tabs.forEach(t => {
      t.classList.toggle('active', t === tab);
      t.setAttribute('aria-selected', t === tab ? "true" : "false");
      t.tabIndex = t === tab ? 0 : -1;
    });
    panels.forEach(panel => {
      panel.classList.toggle('active', panel.id === target);
    });
  }));

  /* ----- SNAKE GAME ----- */
  (function(){
    const canvas = document.getElementById('snake-canvas');
    const ctx = canvas.getContext('2d');
    const scoreElem = document.getElementById('snake-score');
    const gridSize = 20;
    const gridCount = canvas.width / gridSize;
    let snake = [
      {x:8, y:10},
      {x:7, y:10},
      {x:6, y:10}
    ];
    let velocity = {x:1, y:0};
    let food = {x:14, y:10};
    let score = 0;
    let changingDirection = false;
    let gameOver = false;
    let intervalId;

    function placeFood() {
      food.x = Math.floor(Math.random() * gridCount);
      food.y = Math.floor(Math.random() * gridCount);
      while (snake.some(s => s.x === food.x && s.y === food.y)) {
        food.x = Math.floor(Math.random() * gridCount);
        food.y = Math.floor(Math.random() * gridCount);
      }
    }

    function drawBoard() {
      ctx.fillStyle = "#151515";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawFood() {
      ctx.fillStyle = "#f25df5";
      ctx.beginPath();
      ctx.arc((food.x+0.5)*gridSize,(food.y+0.5)*gridSize,gridSize/2.3,0,2*Math.PI);
      ctx.fill();
      ctx.strokeStyle = "#FFF";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawSnake() {
      for (let i = snake.length - 1; i >= 0; i--) {
        if(i === 0) {
          // Draw head with eyes
          ctx.fillStyle = "#4b96eb";
          ctx.beginPath();
          ctx.arc((snake[i].x+0.5)*gridSize, (snake[i].y+0.5)*gridSize, gridSize/2, 0, 2*Math.PI);
          ctx.fill();

          // Eyes (adjust according to direction)
          ctx.fillStyle = "#fff";
          let eyeOffsetX = velocity.x === 1 ? 5 : velocity.x === -1 ? -5 : 0;
          let eyeOffsetY = velocity.y === 1 ? 5 : velocity.y === -1 ? -5 : 0;
          ctx.beginPath();
          ctx.arc((snake[i].x+0.5)*gridSize+eyeOffsetX, (snake[i].y+0.5)*gridSize+eyeOffsetY, 3, 0, 2*Math.PI);
          ctx.arc((snake[i].x+0.5)*gridSize-eyeOffsetX, (snake[i].y+0.5)*gridSize-eyeOffsetY, 3, 0, 2*Math.PI);
          ctx.fill();
        } else {
          ctx.fillStyle = "#beceed";
          ctx.beginPath();
          ctx.arc((snake[i].x+0.5)*gridSize, (snake[i].y+0.5)*gridSize, gridSize/2, 0, 2*Math.PI);
          ctx.fill();
        }
      }
    }

    function update() {
      if (gameOver) return;
      changingDirection = false;
      const head = {
        x: snake[0].x + velocity.x,
        y: snake[0].y + velocity.y
      };

      // Check for collision with walls or self
      if (
        head.x < 0 || head.x >= gridCount ||
        head.y < 0 || head.y >= gridCount ||
        snake.some(s => s.x === head.x && s.y === head.y)
      ) {
        gameOver = true;
        clearInterval(intervalId);
        setTimeout(() => alert('Game Over! Press Restart to play again.'), 100);
        return;
      }

      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        score++;
        scoreElem.textContent = "Score: " + score;
        placeFood();
      } else {
        snake.pop();
      }
      draw();
    }

    function draw() {
      drawBoard();
      drawFood();
      drawSnake();
    }

    function changeDirection(e) {
      if (gameOver) return;
      if (document.getElementById('game-snake').classList.contains('active')) {
        const keys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'];
        if(keys.includes(e.key)) e.preventDefault(); // prevent scrolling
        if(changingDirection) return;
        changingDirection = true;
        switch(e.key) {
          case 'ArrowLeft':
            if(velocity.x !== 1) velocity = {x: -1, y: 0};
            break;
          case 'ArrowUp':
            if(velocity.y !== 1) velocity = {x: 0, y: -1};
            break;
          case 'ArrowRight':
            if(velocity.x !== -1) velocity = {x: 1, y: 0};
            break;
          case 'ArrowDown':
            if(velocity.y !== -1) velocity = {x: 0, y: 1};
            break;
        }
      }
    }

    function resetGame() {
      snake = [
        {x:8, y:10},
        {x:7, y:10},
        {x:6, y:10}
      ];
      velocity = {x:1,y:0};
      score = 0;
      scoreElem.textContent = "Score: 0";
      gameOver = false;
      placeFood();
      if(intervalId) clearInterval(intervalId);
      draw();
      intervalId = setInterval(update, 100);
    }

    document.getElementById('restartSnake').addEventListener('click', resetGame);
    window.addEventListener('keydown', changeDirection);
    resetGame();

  })();

  /* ----- MEMORY MATCH ----- */
  (function() {
    const symbols = ['üçñ','üçï','üç™','üç©','üçâ','üçá','ü••','üçî'];
    const board = document.getElementById('memory-board');
    let cards = [];
    let flipped = [];
    let matchedIds = new Set();
    let lockBoard = false;

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function createCards() {
      let doubled = symbols.concat(symbols);
      shuffle(doubled);
      board.innerHTML = '';
      cards = [];
      doubled.forEach((sym, i) => {
        const card = document.createElement('div');
        card.classList.add('memory-card');
        card.dataset.symbol = sym;
        card.dataset.id = i;

        const front = document.createElement('div');
        front.className = 'front';
        front.textContent = '?';

        const back = document.createElement('div');
        back.className = 'back';
        back.textContent = sym;

        card.appendChild(front);
        card.appendChild(back);

        card.addEventListener('click', flipCard);
        board.appendChild(card);
        cards.push(card);
      });
    }

    function flipCard() {
      if (lockBoard) return;
      if (this.classList.contains('flip')) return;
      if (flipped.length === 2) return;

      this.classList.add('flip');
      flipped.push(this);

      if (flipped.length === 2) {
        checkMatch();
      }
    }

    function checkMatch() {
      lockBoard = true;
      const [first, second] = flipped;

      if (first.dataset.symbol === second.dataset.symbol) {
        matchedIds.add(first.dataset.id);
        matchedIds.add(second.dataset.id);
        resetFlipped();
        checkGameOver();
      } else {
        setTimeout(() => {
          first.classList.remove('flip');
          second.classList.remove('flip');
          resetFlipped();
        }, 900);
      }
    }

    function resetFlipped() {
      flipped = [];
      lockBoard = false;
    }

    function checkGameOver() {
      if (matchedIds.size === cards.length) {
        setTimeout(() => alert('Congratulations! You matched all cards!'), 300);
      }
    }

    document.getElementById('restartMemory').addEventListener('click', () => {
      matchedIds.clear();
      resetFlipped();
      createCards();
    });

    createCards();
  })();

  /* ----- TIC TAC TOE ----- */
  (function(){
    const board = document.getElementById('board');
    const cells = board.querySelectorAll('.cell');
    const message = document.getElementById('message');
    const restartBtn = document.getElementById('restartBtn');
    const winningCombinations = [
      [0,1,2],[3,4,5],[6,7,8],
      [0,3,6],[1,4,7],[2,5,8],
      [0,4,8],[2,4,6]
    ];
    let origBoard;
    let human = 'X';
    let ai = 'O';
    let currentPlayer = human;

    function startGame() {
      origBoard = Array.from(Array(9).keys());
      cells.forEach(cell => {
        cell.textContent = '';
        cell.classList.remove('disabled');
        cell.style.backgroundColor = '';
        cell.addEventListener('click', turnClick, false);
      });
      currentPlayer = human;
      message.textContent = "Your turn! Click a cell.";
    }

    function turnClick(square) {
      if(typeof origBoard[square.target.dataset.index] === 'number') {
        turn(square.target.dataset.index, currentPlayer);
        if(!checkWin(origBoard, currentPlayer) && !checkTie()){
          currentPlayer = ai;
          message.textContent = "AI's turn...";
          setTimeout(() => {
            let bestSpot = minimax(origBoard, ai).index;
            turn(bestSpot, ai);
            if(!checkWin(origBoard, ai) && !checkTie()){
              currentPlayer = human;
              message.textContent = "Your turn! Click a cell.";
            }
          }, 600);
        }
      }
    }

    function turn(index, player) {
      origBoard[index] = player;
      cells[index].textContent = player;
      cells[index].classList.add('disabled');
      let gameWon = checkWin(origBoard, player);
      if(gameWon) gameOver(gameWon);
    }

    function checkWin(board, player) {
      let plays = board.reduce((a,e,i) => (e === player) ? a.concat(i) : a, []);
      let gameWon = null;
      for(let [index, win] of winningCombinations.entries()) {
        if(win.every(elem => plays.indexOf(elem) > -1)) {
          gameWon = {index: index, player: player};
          break;
        }
      }
      return gameWon;
    }

    function gameOver(gameWon) {
      cells.forEach(cell => cell.removeEventListener('click', turnClick, false));
      highlightCells(winningCombinations[gameWon.index]);
      message.textContent = gameWon.player === human ? "You win! üéâ" : "AI wins! üò¢";
    }

    function highlightCells(indices) {
      indices.forEach(i => cells[i].style.backgroundColor = 'var(--accent-color)');
    }

    function checkTie() {
      if(origBoard.filter(s => typeof s === 'number').length === 0){
        message.textContent = "It's a tie!";
        cells.forEach(cell => cell.removeEventListener('click', turnClick, false));
        return true;
      }
      return false;
    }

    function emptySquares() {
      return origBoard.filter(s => typeof s === 'number');
    }

    function minimax(newBoard, player) {
      const availSpots = emptySquares();
      if(checkWin(newBoard, human)) {
        return {score: -10};
      } else if(checkWin(newBoard, ai)) {
        return {score: 10};
      } else if(availSpots.length === 0) {
        return {score: 0};
      }
      let moves = [];
      for(let i=0; i < availSpots.length; i++) {
        let move = {};
        move.index = newBoard[availSpots[i]];
        newBoard[availSpots[i]] = player;
        move.score = player === ai ? minimax(newBoard, human).score : minimax(newBoard, ai).score;
        newBoard[availSpots[i]] = move.index;
        moves.push(move);
      }
      let bestMove;
      if(player === ai){
        let bestScore = -Infinity;
        for(let i=0; i < moves.length; i++){
          if(moves[i].score > bestScore){
            bestScore = moves[i].score;
            bestMove = i;
          }
        }
      } else {
        let bestScore = Infinity;
        for(let i=0; i < moves.length; i++){
          if(moves[i].score < bestScore){
            bestScore = moves[i].score;
            bestMove = i;
          }
        }
      }
      return moves[bestMove];
    }

    restartBtn.addEventListener('click', startGame);
    window.addEventListener('keydown', e => {
      if(document.getElementById('game-tic').classList.contains('active')){
        const keys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'];
        if(keys.includes(e.key)) e.preventDefault();
      }
    });
    startGame();

  })();

  /* ----- SIMON SAYS ----- */
  (function(){
    const buttons = [
      {id: 'btn-green', color: '#0f0'},
      {id: 'btn-red', color: '#f00'},
      {id: 'btn-yellow', color: '#ff0'},
      {id: 'btn-blue', color: '#00f'}
    ];
    let sequence = [];
    let playerSequence = [];
    let waitingForInput = false;
    const message = document.getElementById('simon-message');
    const startBtn = document.getElementById('startSimonBtn');

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function playSequence() {
      waitingForInput = false;
      message.textContent = "Watch the sequence...";
      for (let i = 0; i < sequence.length; i++) {
        const btn = buttons[sequence[i]];
        const element = document.getElementById(btn.id);
        element.style.filter = "brightness(1.5)";
        playSound(btn.color);
        await sleep(700);
        element.style.filter = "brightness(1)";
        await sleep(200);
      }
      message.textContent = "Your turn: Repeat the sequence!";
      waitingForInput = true;
      playerSequence = [];
    }

    function playSound(color) {
      const ctxSound = new AudioContext();
      const oscillator = ctxSound.createOscillator();
      oscillator.type = 'square';
      const freqMap = {'#0f0': 262, '#f00': 294, '#ff0': 330, '#00f': 349};
      oscillator.frequency.setValueAtTime(freqMap[color], ctxSound.currentTime);
      oscillator.connect(ctxSound.destination);
      oscillator.start();
      oscillator.stop(ctxSound.currentTime + 0.3);
    }

    function addStep() {
      sequence.push(Math.floor(Math.random() * 4));
      playSequence();
    }

    function handleButtonClick(index) {
      if (!waitingForInput) return;
      playerSequence.push(index);
      playSound(buttons[index].color);
      if(playerSequence[playerSequence.length-1] !== sequence[playerSequence.length-1]){
        message.textContent = "Wrong! Game over.";
        waitingForInput = false;
        sequence = [];
        return;
      }
      if(playerSequence.length === sequence.length){
        if(sequence.length === 10){
          message.textContent = "You won! Sequence complete.";
          waitingForInput = false;
          sequence = [];
        } else {
          message.textContent = "Correct! Next round...";
          setTimeout(addStep, 1000);
        }
      }
    }

    buttons.forEach(({id}, idx) => {
      const el = document.getElementById(id);
      el.addEventListener('click', () => handleButtonClick(idx));
    });

    startBtn.addEventListener('click', () => {
      if(sequence.length === 0){
        addStep();
      }
    });
  })();

  /* ----- PONG GAME ----- */
  (function(){
    const canvas = document.getElementById('pong-canvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;

    const paddleHeight = 80;
    const paddleWidth = 15;
    const ballRadius = 10;
    let leftPaddleY = (H - paddleHeight)/2;
    let rightPaddleY = (H - paddleHeight)/2;

    let ballX = W/2;
    let ballY = H/2;
    let ballSpeedX = 5;
    let ballSpeedY = 3;

    let leftScore = 0;
    let rightScore = 0;

    const pongScore = document.getElementById('pong-score');

    let keysPressed = {};

    // Control listeners
    window.addEventListener('keydown', e => {
      keysPressed[e.key] = true;
    });
    window.addEventListener('keyup', e => {
      keysPressed[e.key] = false;
    });

    function drawRect(x, y, w, h, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x, y, w, h);
    }
    function drawCircle(x, y, r, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fill();
    }
    function drawNet() {
      ctx.fillStyle = "#4b96eb";
      const netWidth = 2;
      for(let i=0; i<H; i+=20) {
        ctx.fillRect((W/2)-netWidth/2, i, netWidth, 10);
      }
    }

    function draw() {
      drawRect(0, 0, W, H, "#151515");
      drawNet();
      drawRect(5, leftPaddleY, paddleWidth, paddleHeight, "#4b96eb");
      drawRect(W - paddleWidth - 5, rightPaddleY, paddleWidth, paddleHeight, "#f25df5");
      drawCircle(ballX, ballY, ballRadius, "#beceed");
    }

    function movePaddles() {
      if(keysPressed['w'] && leftPaddleY > 0) {
        leftPaddleY -= 7;
      }
      if(keysPressed['s'] && leftPaddleY < H - paddleHeight) {
        leftPaddleY += 7;
      }
      if(keysPressed['ArrowUp'] && rightPaddleY > 0) {
        rightPaddleY -= 7;
      }
      if(keysPressed['ArrowDown'] && rightPaddleY < H - paddleHeight) {
        rightPaddleY += 7;
      }
    }

    function resetBall() {
      ballX = W/2;
      ballY = H/2;
      ballSpeedX = -ballSpeedX;
      ballSpeedY = 3 * (Math.random() > 0.5 ? 1 : -1);
    }

    function update() {
      movePaddles();

      ballX += ballSpeedX;
      ballY += ballSpeedY;

      // Ball collision top/bottom
      if(ballY + ballRadius > H || ballY - ballRadius < 0) {
        ballSpeedY = -ballSpeedY;
      }

      // Ball collision left paddle
      if(ballX - ballRadius < 5 + paddleWidth &&
        ballY > leftPaddleY && ballY < leftPaddleY + paddleHeight){
          ballSpeedX = -ballSpeedX;
          // Add spin based on hit point
          let deltaY = ballY - (leftPaddleY + paddleHeight/2);
          ballSpeedY = deltaY * 0.3;
      }

      // Ball collision right paddle
      if(ballX + ballRadius > W - paddleWidth - 5 &&
        ballY > rightPaddleY && ballY < rightPaddleY + paddleHeight){
          ballSpeedX = -ballSpeedX;
          let deltaY = ballY - (rightPaddleY + paddleHeight/2);
          ballSpeedY = deltaY * 0.3;
      }

      // Left misses ball
      if(ballX < 0) {
        rightScore++;
        pongScore.textContent = `Player 1: ${leftScore} | Player 2: ${rightScore}`;
        resetBall();
      }

      // Right misses ball
      if(ballX > W) {
        leftScore++;
        pongScore.textContent = `Player 1: ${leftScore} | Player 2: ${rightScore}`;
        resetBall();
      }
    }

    function gameLoop() {
      update();
      draw();
    }

    document.getElementById('restartPong').addEventListener('click', () => {
      leftScore = 0;
      rightScore = 0;
      pongScore.textContent = `Player 1: 0 | Player 2: 0`;
      resetBall();
    });

    setInterval(gameLoop, 1000/60);
  })();
</script>
</body>
</html>
